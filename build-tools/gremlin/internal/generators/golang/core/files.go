/*
               .'\   /`.
             .'.-.`-'.-.`.
        ..._:   .-. .-.   :_...
      .'    '-.(o ) (o ).-'    `.
     :  _    _ _`~(_)~`_ _    _  :
    :  /:   ' .-=_   _=-. `   ;\  :
    :   :|-.._  '     `  _..-|:   :
     :   `:| |`:-:-.-:-:'| |:'   :
      `.   `.| | | | | | |.'   .'
        `.   `-:_| | |_:-'   .'
          `-._   ````    _.-'
              ``-------''

Created by ab, 13.10.2022
*/

package core

import (
	"fmt"
	"octopus/build-tools/gremlin/internal/types"
	"strconv"
	"strings"
)

type GoGeneratedFile struct {
	imports            []*GoImport
	samePackageImports []*GoGeneratedFile

	enums   []GoType
	structs []GoType

	ProtoFile        *types.ProtoFile
	Path             string
	FullPackageName  string
	ShortPackageName string
	FullOutputPath   string
}

func (g *GoGeneratedFile) AddImport(path string, alias string) {
	for _, goImport := range g.imports {
		if goImport.Path == path {
			return
		}
	}

	usedAliases := 0
	for _, goImport := range g.imports {
		if goImport.Alias == alias {
			usedAliases++
		}
	}

	if usedAliases > 0 {
		alias += "_" + strconv.Itoa(usedAliases)
	}

	g.imports = append(g.imports, &GoImport{
		Path:  path,
		Alias: alias,
		Used:  true,
	})
}

func (g *GoGeneratedFile) AddProtoImport(targetFile *GoGeneratedFile) {
	if targetFile.FullPackageName == g.FullPackageName {
		g.samePackageImports = append(g.samePackageImports, targetFile)
		return
	}

	var found = false
	for i := range g.imports {
		if g.imports[i].Path == targetFile.FullPackageName {
			found = true
			g.imports[i].GoFiles = append(g.imports[i].GoFiles, targetFile)
			break
		}
	}

	if !found {
		usedAliases := 0
		for _, goImport := range g.imports {
			if goImport.Alias == targetFile.ShortPackageName {
				usedAliases++
			}
		}

		var alias = targetFile.ShortPackageName
		if usedAliases > 0 {
			alias += "_" + strconv.Itoa(usedAliases)
		}

		g.imports = append(g.imports, &GoImport{
			Path:    targetFile.FullPackageName,
			Alias:   alias,
			GoFiles: []*GoGeneratedFile{targetFile},
		})
	}
}

func (g *GoGeneratedFile) AddEnum(enum GoType) {
	g.enums = append(g.enums, enum)
}

func (g *GoGeneratedFile) AddStruct(structDef GoType) {
	g.structs = append(g.structs, structDef)
}

func (g *GoGeneratedFile) FindEnum(enumType *types.EnumDefinition) GoType {
	for _, enum := range g.enums {
		if enum.IsEnum(enumType) {
			return enum
		}
	}
	return nil
}

func (g *GoGeneratedFile) FindStruct(msgType *types.MessageDefinition) GoType {
	for _, goType := range g.structs {
		if goType.IsStruct(msgType) {
			return goType
		}
	}
	return nil
}

func (g *GoGeneratedFile) FindEnumInImports(enumFile *types.ProtoFile, enumType *types.EnumDefinition) (string, GoType) {
	for _, goFile := range g.samePackageImports {
		if goFile.ProtoFile == enumFile {
			return "", goFile.FindEnum(enumType)
		}
	}
	for _, goImport := range g.imports {
		for _, file := range goImport.GoFiles {
			if file.ProtoFile == enumFile {
				goImport.Used = true
				return goImport.Alias, goImport.FindEnum(enumType)
			}
		}
	}
	return "", nil
}

func (g *GoGeneratedFile) FindStructInImports(msgFile *types.ProtoFile, msgType *types.MessageDefinition) (string, GoType) {
	for _, goFile := range g.samePackageImports {
		if goFile.ProtoFile == msgFile {
			return "", goFile.FindStruct(msgType)
		}
	}
	for _, goImport := range g.imports {
		for _, file := range goImport.GoFiles {
			if file.ProtoFile == msgFile {
				goImport.Used = true
				return goImport.Alias, goImport.FindStruct(msgType)
			}
		}
	}
	return "", nil
}

type GoImport struct {
	Path    string
	Alias   string
	GoFiles []*GoGeneratedFile
	Used    bool
}

func (g *GoImport) FindEnum(enumType *types.EnumDefinition) GoType {
	for _, goFile := range g.GoFiles {
		if enum := goFile.FindEnum(enumType); enum != nil {
			return enum
		}
	}
	return nil
}

func (g *GoImport) FindStruct(msgType *types.MessageDefinition) GoType {
	for _, goFile := range g.GoFiles {
		if structType := goFile.FindStruct(msgType); structType != nil {
			return structType
		}
	}
	return nil
}

func (g *GoGeneratedFile) GenerateCode() string {
	if len(g.structs) > 0 {
		g.AddImport("octopus/shared/gremlin", "gremlin")
	}
	sb := &strings.Builder{}

	sb.WriteString(fmt.Sprintf(`// Code generated by gremlin. DO NOT EDIT.
// source: %v

package %v

`, g.ProtoFile.RelativePath, g.ShortPackageName))

	var filtered []*GoImport
	for i := range g.imports {
		if g.imports[i].Used {
			filtered = append(filtered, g.imports[i])
		}
	}

	if len(filtered) > 1 {
		sb.WriteString("import (\n")
		for _, goImport := range filtered {
			sb.WriteString(fmt.Sprintf("\t%v \"%v\"\n", goImport.Alias, goImport.Path))
		}
		sb.WriteString(")\n")
	} else if len(filtered) == 1 {
		sb.WriteString(fmt.Sprintf("import %v %q\n", filtered[0].Alias, filtered[0].Path))
	}

	for _, enum := range g.enums {
		enum.GenerateCode(sb)
	}

	for _, structDef := range g.structs {
		structDef.GenerateCode(sb)
	}

	return sb.String()
}
